// This is autogenerated code by Norman Ziebal

// First Table:
// <A>                            gamma, alp, beta              
// <7ae26052>                     b                             
// <start>                        gamma, alp, beta              
// <__start_internal>             gamma, alp, beta              
// <db106f01>                     ha                            

// Follow Table Table:
// $                              $                             
// <A>                            $                             
// gamma                          $                             
// beta                           $                             
// <7ae26052>                     $                             
// <start>                        $                             
// alp                            $, ha                         
// <__start_internal>             $                             
// b                              $                             
// <db106f01>                     $                             
//                                $                             
// ha                             b, $


int getShortestStringLength(string array[], int size) {
    local int i;
    local int l;
    local int length = 10000;
    for (i = 0; i < size; i++) {
        l = Strlen(array[i]);
        if (l < length) {
            length = l;
        }
    }
    return length;
}

int findSelection(string selection, string pv[], int size, int shortest) {
    local int i;
    for (i = 0; i < size; i++) {
        if (Strncmp(selection, pv[i], shortest) == 0) {
            break;
        }
    }
    // Printf("%s", pv[i]);
    return i;
}

string getToken(string possible_tokens[], int size) {
    local int shortest = getShortestStringLength(possible_tokens, size);
    local string preferred_values[size];

    local int i;
    for (i = 0; i < size; i++) {
        // Printf("%s\n", SubStr(possible_tokens[i], 0, shortest));
        preferred_values[i] = SubStr(possible_tokens[i], 0, shortest);
    }

    local char selection[shortest];
    ReadBytes(selection, FTell(), shortest, preferred_values);
    //Printf("%s\n", selection);

    local int index = findSelection(selection, possible_tokens, size, shortest);
    local int target_length = Strlen(possible_tokens[index]);
    local char selection_full[target_length];
    local string new_pv[1];
    new_pv[0] = possible_tokens[index];
    ReadBytes(selection_full, FTell(), target_length, new_pv);

    return selection;
}

// Global Defines
struct START_NONTERMINAL_9A43E7(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {};
struct A_NONTERMINAL_BB5D5D(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {};
struct AE_NONTERMINAL_479C58(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {};
struct DBF_NONTERMINAL_B10196(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {};
struct STARTINTERNAL_NONTERMINAL_5DF3F9(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {};

// Code Section
struct START_NONTERMINAL_9A43E7(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {

	if (first_is_eof) {
		if (FEof(0.25)) {
			Printf("START_NONTERMINAL_9A43E7 - EOF\n");
			return;
		}
	}

	local char selection[5];
	selection = getToken(first, 3);
	switch (selection) {
		case "alp":
			// ######################################################################################################
			//
			// STARTINTERNAL_NONTERMINAL_5DF3F9
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <__start_internal>, $
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => $
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: $
			// FOLLOW IS_EOF? YES
			//
			// new_first = alp, gamma, beta
			// new_follow = $
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 1;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size;
			STARTINTERNAL_NONTERMINAL_5DF3F9 startinternal_nonterminal_5df3f9(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		case "beta":
			// ######################################################################################################
			//
			// STARTINTERNAL_NONTERMINAL_5DF3F9
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <__start_internal>, $
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => $
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: $
			// FOLLOW IS_EOF? YES
			//
			// new_first = alp, gamma, beta
			// new_follow = $
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 1;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size;
			STARTINTERNAL_NONTERMINAL_5DF3F9 startinternal_nonterminal_5df3f9(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		case "gamma":
			// ######################################################################################################
			//
			// STARTINTERNAL_NONTERMINAL_5DF3F9
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <__start_internal>, $
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => $
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: $
			// FOLLOW IS_EOF? YES
			//
			// new_first = alp, gamma, beta
			// new_follow = $
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 1;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size;
			STARTINTERNAL_NONTERMINAL_5DF3F9 startinternal_nonterminal_5df3f9(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		default:
			return -1;
	}

};

struct A_NONTERMINAL_BB5D5D(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {

	if (first_is_eof) {
		if (FEof(0.25)) {
			Printf("A_NONTERMINAL_BB5D5D - EOF\n");
			return;
		}
	}

	local char selection[5];
	selection = getToken(first, 3);
	switch (selection) {
		case "alp":
			char ALP_TERMINAL_5F4940[3] = { "alp" };

			// ######################################################################################################
			//
			// DBF_NONTERMINAL_B10196
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <db106f01>
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => Empty
			//
			// FIRST: epsi, ha
			// FOLLOW: Empty
			// FOLLOW IS_EOF? NO
			// FOLLOW is EMPTY: we need to include the CALLEE follow information
			// FIRST contains epsi: we need FOLLOW information
			//
			// new_first = epsi, ha
			// new_follow = Empty
			// new_follow += follow
			// new_first += new_follow
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 0;
			local string new_first[] = {"ha"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size + follow_size;
			local string new_follow[new_follow_size];
			local int i;
			for (i = temp_new_follow_size; i < new_follow_size; i++) {
				new_follow[i] = follow[i - temp_new_follow_size];
			}
			
			new_follow_is_eof |= follow_is_eof;
			local int org_size_first = 1;
			local int new_first_size = org_size_first + new_follow_size;
			local string new_first[new_first_size];
			local int j;
			for (j = org_size_first; j < new_first_size; j++) {
				new_first[j] = new_follow[j - org_size_first];
			}
			
			new_first_is_eof |= follow_is_eof;
			DBF_NONTERMINAL_B10196 dbf_nonterminal_b10196(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		case "beta":
			char BETA_TERMINAL_6EBFFD[4] = { "beta" };

			break;
		case "gamma":
			char GAMMA_TERMINAL_99D6CF[5] = { "gamma" };

			break;
		default:
			return -1;
	}

};

struct AE_NONTERMINAL_479C58(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {

	if (first_is_eof) {
		if (FEof(0.25)) {
			Printf("AE_NONTERMINAL_479C58 - EOF\n");
			return;
		}
	}

	local char selection[5];
	selection = getToken(first, 1);
	switch (selection) {
		case "b":
			char B_TERMINAL_314D4B[1] = { "b" };

			break;
		default:
			return -1;
	}

};

struct DBF_NONTERMINAL_B10196(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {

	if (first_is_eof) {
		if (FEof(0.25)) {
			Printf("DBF_NONTERMINAL_B10196 - EOF\n");
			return;
		}
	}

	local char selection[5];
	selection = getToken(first, 1);
	switch (selection) {
		case "ha":
			char HA_TERMINAL_AFEF9B[2] = { "ha" };

			// ######################################################################################################
			//
			// AE_NONTERMINAL_479C58
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <7ae26052>
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => Empty
			//
			// FIRST: b, epsi
			// FOLLOW: Empty
			// FOLLOW IS_EOF? NO
			// FOLLOW is EMPTY: we need to include the CALLEE follow information
			// FIRST contains epsi: we need FOLLOW information
			//
			// new_first = b, epsi
			// new_follow = Empty
			// new_follow += follow
			// new_first += new_follow
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 0;
			local string new_first[] = {"b"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size + follow_size;
			local string new_follow[new_follow_size];
			local int i;
			for (i = temp_new_follow_size; i < new_follow_size; i++) {
				new_follow[i] = follow[i - temp_new_follow_size];
			}
			
			new_follow_is_eof |= follow_is_eof;
			local int org_size_first = 1;
			local int new_first_size = org_size_first + new_follow_size;
			local string new_first[new_first_size];
			local int j;
			for (j = org_size_first; j < new_first_size; j++) {
				new_first[j] = new_follow[j - org_size_first];
			}
			
			new_first_is_eof |= follow_is_eof;
			AE_NONTERMINAL_479C58 ae_nonterminal_479c58(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		default:
			return -1;
	}

};

struct STARTINTERNAL_NONTERMINAL_5DF3F9(string first[], string follow[], int follow_size, int first_is_eof, int follow_is_eof) {

	if (first_is_eof) {
		if (FEof(0.25)) {
			Printf("STARTINTERNAL_NONTERMINAL_5DF3F9 - EOF\n");
			return;
		}
	}

	local char selection[5];
	selection = getToken(first, 3);
	switch (selection) {
		case "alp":
			// ######################################################################################################
			//
			// A_NONTERMINAL_BB5D5D
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <A>
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => Empty
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: Empty
			// FOLLOW IS_EOF? NO
			// FOLLOW is EMPTY: we need to include the CALLEE follow information
			//
			// new_first = alp, gamma, beta
			// new_follow = Empty
			// new_follow += follow
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 0;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size + follow_size;
			local string new_follow[new_follow_size];
			local int i;
			for (i = temp_new_follow_size; i < new_follow_size; i++) {
				new_follow[i] = follow[i - temp_new_follow_size];
			}
			
			new_follow_is_eof |= follow_is_eof;
			A_NONTERMINAL_BB5D5D a_nonterminal_bb5d5d(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		case "beta":
			// ######################################################################################################
			//
			// A_NONTERMINAL_BB5D5D
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <A>
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => Empty
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: Empty
			// FOLLOW IS_EOF? NO
			// FOLLOW is EMPTY: we need to include the CALLEE follow information
			//
			// new_first = alp, gamma, beta
			// new_follow = Empty
			// new_follow += follow
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 0;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size + follow_size;
			local string new_follow[new_follow_size];
			local int i;
			for (i = temp_new_follow_size; i < new_follow_size; i++) {
				new_follow[i] = follow[i - temp_new_follow_size];
			}
			
			new_follow_is_eof |= follow_is_eof;
			A_NONTERMINAL_BB5D5D a_nonterminal_bb5d5d(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		case "gamma":
			// ######################################################################################################
			//
			// A_NONTERMINAL_BB5D5D
			//
			// first: Set[Token] = self.__first_set.get(tokens[index:]) => <A>
			// follow: Set[Token] = self.__first_set.get(tokens[(index + 1):]) => Empty
			//
			// FIRST: alp, gamma, beta
			// FOLLOW: Empty
			// FOLLOW IS_EOF? NO
			// FOLLOW is EMPTY: we need to include the CALLEE follow information
			//
			// new_first = alp, gamma, beta
			// new_follow = Empty
			// new_follow += follow
			//
			// ######################################################################################################
			local int new_first_is_eof = 0;
			local int new_follow_is_eof = 0;
			local string new_first[] = {"alp", "beta", "gamma"};
			local string new_follow[0];
			local int temp_new_follow_size = 0;
			local int new_follow_size = temp_new_follow_size + follow_size;
			local string new_follow[new_follow_size];
			local int i;
			for (i = temp_new_follow_size; i < new_follow_size; i++) {
				new_follow[i] = follow[i - temp_new_follow_size];
			}
			
			new_follow_is_eof |= follow_is_eof;
			A_NONTERMINAL_BB5D5D a_nonterminal_bb5d5d(new_first, new_follow, new_follow_size, new_first_is_eof, new_follow_is_eof);

			break;
		default:
			return -1;
	}

};

SetEvilBit(false);
local string possible_values[] = {"alp", "beta", "gamma"};
local string required_follows[0];
START_NONTERMINAL_9A43E7 start(possible_values, required_follows, 0, 0, 1);
